# Дорожная карта проекта «Batumi Trip»

## 1. Введение

SPA «Batumi Trip» — это одностраничное приложение для совместного планирования путешествий небольшой группы друзей. Оно позволяет обмениваться понравившимися локациями и планировать поездку группой (без высоких нагрузок и масштабирования). Целевая аудитория — порядка 10 друзей, поэтому требования к масштабируемости невелики. Основные функции: просмотр списка локаций (карточек с фото, заголовком, описанием, тегами), добавление/редактирование/удаление своих локаций, поиск по заголовку и тегам, отметка локаций «избранное» и авторизация по логину без пароля (magic link).

### 1.1 Цель

Обеспечить пошаговую техническую дорожную карту (roadmap) по разработке SPA «Batumi Trip». Документ описывает этапы спринтов от S0 до S6, их задачи и критерии приёмки. Цель – четко определить масштаб работ, требования к качеству и контрольные точки, чтобы одиночный разработчик, используя кодогенерацию и CI/CD на Vercel, мог последовательно реализовать все фичи согласно спецификации.

### 1.2 Definition of Done (Критерии завершенности)

Проект считается завершенным, когда выполнены следующие требования (минимальные пороги):

* **Тестирование:** покрытие unit- и e2e-тестами ≥ 70%.
* **Lighthouse:** баллы ≥ 90 по метрикам Performance и Accessibility.
* **Соответствие StyleGuide:** все компоненты и страницы соответствуют гайдлайнам (Tailwind+shadcn/ui, доступность).
* **API-ответы:** для авторизованного запроса (валидный JWT/cookie) все REST/RPC-маршруты возвращают статус 2xx при корректном вводе.

### 1.3 Точки входа в контекст

Ключевые документы архитектуры и дизайна проекта:

* **User Stories:** функциональные требования – UserStory-BatumiTrip.md.
* **Архитектура:** стек технологий, структура директорий, model db – Architecture-BatumiTrip.md.
* **Модель данных:** схема БД (таблицы users, locations, tags, locations_tags, favourites) – DataModel-BatumiTrip.md.
* **API:** спецификация REST-маршрутов и NextAuth – API-BatumiTrip.md.
* **Дизайн компонентов:** React-компоненты, их иерархия и контракты – ComponentsDesign-BatumiTrip.md.
* **State Management:** React Query, Zustand, Context API – StateManagement-BatumiTrip.md.
* **StyleGuide:** визуальные и UI-решения (цвета, отступы, доступность) – StyleGuide-BatumiTrip.md.

---
## 2. Базовые артефакты

Ниже приведена матрица трассировки между ключевыми пользовательскими историями и документами-артефактами, описывающими их реализацию:

| User Story № / Функционал | Связанные документы (артефакты) |
|---------------------------|---------------------------------|
| Просмотр списка локаций (карточки) | ComponentsDesign (LocationListPage, LocationCard), StyleGuide, StateManagement (useLocations, Zustand) |
| Добавление новой локации | ComponentsDesign (LocationForm, AddLocationPage), API (POST /locations), DataModel (таблица locations, связи tags) |
| Детальная страница локации | ComponentsDesign (LocationDetail, EditButton, DeleteButton), API (GET, PATCH, DELETE /locations) |
| Редактирование/удаление локации | ComponentsDesign (LocationForm для редактирования, DeleteButton), API (PATCH/DELETE) |
| Поиск по заголовку/тегам | ComponentsDesign (SearchBar, TagBadge), StateManagement (Zustand хранит searchQuery и selectedTags) |
| Авторизация (логин без пароля) | Architecture (NextAuth credential provider), API (POST `/api/auth/signin`) |
| Избранное (favourites) | DataModel (таблица favourites и RLS), StateManagement (React Query ключ `['favourites', userId]`, Zustand.store.favorites), ComponentsDesign (useToggleFavourite) |
> Матрица показывает, какие разделы проектной документации охватывают каждую ключевую функцию (см. TaskIndex.md).

---
## 3. Допущения и ограничения

* **SPA (Single Page App):** весь UI реализуется на клиенте (Next.js 14, App Router). Нет многостраничного рендеринга на сервере.
* **Friends-only:** приложение предназначено для личного круга; нет требований к публичной регистрации или масштабируемости. Нагрузка невысока (10 пользователей), поэтому Supabase можно использовать на free-tier.
* **Supabase (free-tier):** использует базу данных PostgreSQL с RLS, хранилище и аутентификацию. На free-tier ограничены размеры БД и ежемесячные квоты, но для 10 пользователей и статических загрузок этого достаточно.
* **Деплой на Vercel:** используем платформу Vercel для CI/CD и хостинга (автодеплой из main). Приложение работает как статический/SSR-сайт.
* **Без Edge-функций:** не реализуем Edge-функции Supabase (например, геокодинг или webhook). При добавлении локации адрес хранится как текст, геокодинг делается вне проекта или вручную.
* **CI и проверка:** подключены ESLint/Prettier (lint), тестовые фреймворки для юнит и e2e.
* **Одиночный разработчик + ИИ:** код генерируется с помощью GPT‑4o по промптам, но ответственность за его качество и безопасность несет человек. Требуется тщательный ревью с тестами.

---
## 4. Обзор спринтов

| Спринт | Цели |
|--------|------|
| **S0** | Подготовка: инициализация репозитория, базовая архитектура, подключение Supabase, NextAuth |
| **S1** | Реализация аутентификации и главной страницы: логин без пароля, отображение списка локаций |
| **S2** | Функция добавления локации: страница *AddLocation*, форма, сохранение в БД (локи+теги) |
| **S3** | Детальные данные локации: страница *LocationDetail*, редактирование и удаление |
| **S4** | Поиск и избранное: поиск по названию/тегам, реализация «избранного» (toggle favourite) |
| **S5** | Полировка UI/UX: приведение к StyleGuide, адаптивность, оптимизация, Lighthouse |
| **S6** | Качество и релиз: тесты (unit+e2e ≥70%), CI/CD, документация, деплой на продакшн |

> Цели спринтов согласованы с функциональными требованиями (см. User Story и матрицу требований выше).

---
## 5. Детальная декомпозиция спринтов

### S0. Подготовка инфраструктуры и каркас

* **Цели:** создать основу проекта, которая включит все необходимое для последующей разработки.
* **Задачи:**

  * Инициализировать новый проект Next.js 14 (App Router) с папками `app/`, `components/`, `lib/`, `store/`, `supabase/`, настроить `tailwind.config.js`, глобальные стили. (см. Architecture: структура директорий).
  * Настроить Supabase (free-tier): создать проект, подготовить миграции для таблиц `users`, `locations`, `tags`, `locations_tags`, `favourites` (см. DataModel).
  * Настроить NextAuth (Credentials Provider без пароля): маршруты `/api/auth` и middleware в `middleware.ts` для проверки сессии и HTTP-only cookie.
  * Добавить CI/CD: репозиторий на GitHub, подключить авто-деплой на Vercel (каждый push в main). Настроить линтер и проверку стиля (ESLint, Prettier) в CI.
  * Создать пример заготовочный Landing Page (App layout) с навигацией и модулем `LoginModal` (пока пустой).
* **Deliverables:**

  * Репозиторий с базовой структурой согласно architecture.
  * Данные таблицы (миграции) загружены в Supabase (без данных).
  * Работает NextAuth: при первом логине (ввод логина) создается запись в `users`.
  * Настроен CI: проходит lint и «hello world» тест (пустой).
* **Критерии приёмки:**

  * Проект корректно стартует (`npm run dev`) без ошибок сборки.
  * При вводе пользовательского логина (например, «alice») через NextAuth создается `users.id = "alice"` (см. API spec).
  * Middleware защищает приватные маршруты (redirect на логин).
  * CI-пайплайн проходит (lint без ошибок).

### S1. Аутентификация и главная страница (листинг)

* **Цели:** обеспечить вход пользователя и отрисовку списка локаций (заглушка/скелетон при загрузке).
* **Задачи:**

  * Реализовать `LoginModal`: простая форма (поле для логина + кнопка), использующая `next-auth` для SignIn. При успешном входе перенаправлять на главную страницу.
  * Добавить компонент `Header` (с кнопкой «Выйти» и пользовательским именем).
  * Создать страницу *LocationListPage* (роутинг `/`): компонент-оболочку, в которой вызывается кастомный хук `useLocations` (React Query), а внутри рендерятся `SearchBar`, `AddLocationButton` и `LocationList`.
  * Компонент `LocationList`: при загрузке данных отображает `SkeletonCard`, после — список `LocationCard` (структура карточки из ComponentsDesign: фото, заголовок, начало описания, теги, стоимость). Клик на карточке переводит на детальную страницу.
  * Заготовить `AddLocationButton` (ссылка на `/locations/new`).
* **Deliverables:**
  * Главная страница `/` доступна после логина и показывает массив карточек (пока пустой список => skeleton).
  * Реализована регистрация/вход: при вводе нового логина создаётся пользователь (Supabase RLS разрешает вставку).
  * Скелетон-карточки по дизайну StyleGuide.
* **Критерии приёмки:**
  * При отсутствии локаций отображается анимированный `SkeletonCard`.
  * Локальное состояние поиска (`searchQuery`) и выбранных тегов (Zustand) меняется при вводе текста/выборе.

### S2. Добавление новой локации

* **Цели:** реализовать создание и сохранение новых локаций вместе с тегами и изображением.
* **Задачи:**

  * Создать страницу *AddLocationPage* (`/locations/new`): содержит `LocationForm` без `initialData`.
  * `LocationForm`: поля *title, description, address, cost, sourceUrl, uploadImage, multi-select tags* (данные теги из таблицы `tags`). Использовать React Hook Form + shadcn/ui элементы. Валидация полей (required title).
  * При сабмите формы (POST) вызывать Supabase REST: `POST /rest/v1/locations` для создания записи (включая поля title, description, адрес и др.). Если загружено изображение, сохранять его в Supabase Storage и записать ссылку в `image_url`.
  * После создания получить `location_id`, связать теги: для каждого выбранного тега вызвать RPC-функцию или вставку в `locations_tags`. Можно использовать RPC `add_location_tag({ location_id, tag_id })`.
  * После успешного сохранения перенаправлять на `/locations/{id}` (деталь локации).
* **Deliverables:**

  * Форма добавления локации работает: при введении данных и отправке новая локация сохраняется в БД (таблица `locations`), связываются теги (таблица `locations_tags`).
  * Изображение загружается в Supabase Storage и URL сохраняется в записи.
  * Теги: новые не создаются (если нужно, добавить INSERT в `tags`), фильтрация по существующим.
* **Критерии приёмки:**

  * Новая локация появляется в списке на главной странице сразу после редиректа.
  * В базе в таблице `locations` есть новая запись (проверить через Supabase UI).
  * В таблице `locations_tags` соответствующие связи (каждая пара location\_id–tag\_id) добавлены.
  * Страница перенаправления `/locations/{id}` загружает только что созданную локацию.
  * UI-валидация работает (например, нельзя сохранить без названия).

### S3. Детальная страница локации, редактирование и удаление

* **Цели:** показывать полную информацию локации, реализовать правку и удаление своих локаций.
* **Задачи:**

  * Страница *LocationDetailPage* (`/locations/{id}`): роут Next.js. Вызывать хук `useOneLocation(id)` (React Query) для загрузки одной локации вместе с её тегами и списком текущих favorites.
  * Компонент `LocationDetail`: отображает поля (title, image, address, cost, sourceUrl, description, теги через `TagBadge`). Кнопки `EditButton` и `DeleteButton` рядом.
  * `EditButton`: при клике редиректит на `/locations/{id}/edit`.
  * Страница *EditLocationPage* (`/locations/{id}/edit`): рендерит тот же `LocationForm` с `initialData` из загруженной локации. При сабмите вызывает PATCH к `/rest/v1/locations?id=eq.{id}`.
  * `DeleteButton`: при клике запрашивает подтверждение (window\.confirm). Если да, выполнить DELETE `/rest/v1/locations?id=eq.{id}`. С помощью `rpc sync_location_tags` или RLS каскад удалит связанные записи в `locations_tags` и `favourites`. После успеха делать `router.push('/')`.
* **Deliverables:**

  * Детальная страница `/locations/{id}` показывает все данные локации (как в макете).
  * Открытие `/locations/{id}/edit` даёт заполненную форму. Сохранение вносит изменения (проверить в БД).
  * Функция удаления удаляет запись и связанные с ней favorites/теги. Пользователь возвращается на главную страницу.
* **Критерии приёмки:**

  * На детальной странице отображаются именно те данные, которые введены при создании/редактировании. Теги выводятся правильными бейджами (`TagBadge` из ComponentsDesign).
  * После редактирования изменения видны и в БД.
  * Удаление локации из базы приводит к её исчезновению из списка (check через Supabase).
  * Запросы возвращают 2xx при валидном JWT (NextAuth cookie) и корректных данных.

### S4. Поиск и избранное

* **Цели:** добавить поиск/фильтрацию и возможность отмечать локации как избранное.
* **Задачи:**

  * `SearchBar` (на главной): текстовое поле для поиска по заголовку и селект для тегов. При вводе/выборе обновлять Zustand (`searchQuery` и `selectedTags`), это влияет на ключи React Query (`useLocations({ search, tags })` из StateManagement). Бэкенд-подзапрос к Supabase должен фильтровать по `title=ilike.%search%` и наличию tag (через `locations_tags`).
  * Переработать `useLocations` (React Query): принимать параметры поиска, `useInfiniteQuery` для подгрузки страниц. При изменении параметров полностью перезапрашивать список.
  * В `LocationCard` добавить иконку «звёздочка» (пустая/заполненная). При клике вызывать `useToggleFavourite(id)`. Этот хук делает POST или DELETE в таблицу `favourites` (текущий user\_id) и оптимистично обновляет локальное состояние (Zustand `favorites` и React Query).
  * После клика по звёздочке состояние интерфейса сразу меняется (без ожидания ответа).
* **Deliverables:**

  * Поисковая строка работает: при вводе фильтрует список на лету (отображается уже не все локации, а соответствующие запросу).
  * Реализована фильтрация по нескольким тегам (мультиселект TagBadge или drop-down).
  * Избранное: пользователь может отмечать/снимать «лайк» (favourite) на карточках. Количество «лайков» нигде не отображается, но сам статус сохраняется в таблице `favourites`. Иконка меняет вид.
* **Критерии приёмки:**

  * После клика на ⭐ в `LocationCard` для текущего пользователя создаётся или удаляется запись в `favourites` (проверка в Supabase).
  * Состояние избранного отражается сразу (оптимистическое обновление, не дожидаясь ответа).
  * Поиск по тексту/тегам корректно фильтрует (например, слово должно проходить через `%ilike%` запрос).
  * При взаимодействии нет заметных задержек (React Query и Zustand обеспечивают плавность).

### S5. Полировка UI/UX и производительность

* **Цели:** привести интерфейс к финальному виду согласно гайдлайнам и обеспечить высокую производительность.
* **Задачи:**

  * Применить StyleGuide: единообразные шрифты, цвета (primary, secondary), отступы и тени. Проверить, что компоненты использовали Tailwind-классы из `tailwind.config.js` (цвета `bg-primary`, `text-foreground` и др.). Обеспечить Dark Mode (класс `dark` на root).
  * Убедиться в доступности: корректные aria-атрибуты для кнопок и форм, возможность управления клавиатурой.
  * Оптимизировать загрузку ресурсов: сжать изображения, ленивый `loading="lazy"` для картинок. Настроить `<Link>` для переходов.
  * Настроить Lighthouse-тест: проанализировать страницу и привести метрики **Performance >= 90, Accessibility >= 90**. Исправить замечания (например, минимизировать bundle, использовать кеширование).
* **Deliverables:**

  * Интерфейс соответствует StyleGuide (во всех компонентах применены стандартизованные цвета и компоненты из shadcn/ui).
  * Мобильная адаптивность: верстка корректно смотрится на смартфонах (breakpoints).
  * Lighthouse: отчёт сборщика CI показывает баллы ≥ 90 по основным метрикам.
* **Критерии приёмки:**

  * Все страницы соответствуют UI Guidelines (проверка визуально и по коду).
  * По умолчанию и в тёмной теме соблюдаются контрастные сочетания (`primary` vs `background` и т.д.).
  * Без багов адаптивности при ширине от 320px до 1920px.
  * Lighthouse отчёт (в CI или локально) показывает `Performance ≥ 90`, `Accessibility ≥ 90`, `Best Practices` высокие.

### S6. Тестирование, CI/CD и релиз

* **Цели:** обеспечить стабильность и завершить релиз.
* **Задачи:**

  * Написать unit-тесты (Jest/React Testing Library) для ключевых компонентов и хуков (`useLocations`, `useOneLocation`, `useToggleFavourite`, `LocationForm` и др.). Достигнуть охвата кода ≥ 70 %.
  * Настроить e2e-тесты (Cypress/Playwright): проверить сценарии: регистрация пользователя, создание локации, поиск, постановка лайка, редактирование, удаление.
  * Расширить CI: при PR прогонять линтер, unit-тесты, e2e-тесты; остановка на падении.
  * Написать README/Roadmap.md (данный документ) в папке `/docs`. Прописать инструкции по запуску, окружению (переменные Supabase, NEXTAUTH\_SECRET), деплою (Vercel).
  * Финальный деплой: проверка на стейджинге, после чего пуш в main и релиз на продакшн.
* **Deliverables:**

  * Сборка CI зелёная: во всех тестах покрытие ≥ 70%.
  * Работающий бэкенд и фронтенд на Vercel (статичный URL).
  * Документация проекта (в том числе StyleGuide, API spec, данный Roadmap) оформлена и обновлена.
* **Критерии приёмки:**

  * На GitHub Actions пройдены все шаги (lint, тесты). Покрытие отмечено в отчетах (≥ 70%).
  * Пользовательские сценарии (см. User Stories) проверены вручную и e2e-тестами без сбоев.
  * Приложение доступно в продакшн-среде, а логирование/мониторинг (Vercel) не показывает критических ошибок.

---
## 6. Контроль качества и роль ИИ

Процесс разработки включает следующие этапы:

* **Prompt (ИИ-кодогенерация):** ключевые функции описываются в виде детальных промптов, после чего GPT‑4o генерирует фрагменты кода (компоненты, хуки, SQL-запросы и т.п.).
* **Pull Request:** полученный код вносится в репозиторий через pull request. Каждая задача оформляется как отдельный PR.
* **CI (linт + tests):** на каждое PR CI-пайплайн автоматически запускает проверку кода: статический анализ (ESLint/Prettier), unit- и интеграционные тесты. PR «запрещен» к слиянию, пока все статусы зелёные.
* **Код-ревью (человек):** мерж осуществляется только после ревью другим разработчиком (или заказчиком): проверяются безопасность (нет XSS/SQLi), соответствие StyleGuide, корректность логики. Особое внимание уделяется коду из ИИ (он должен быть понятен и оптимизирован).
* **Merge:** после одобрения PR сливается в main. Каждое слияние в main автоматически деплоит приложение (Vercel).

> Таким образом ИИ выступает в роли ускорителя разработки (выполняет рутинную работу по написанию кода), а контроль качества обеспечивается цепочкой PR → CI (lint, тесты) → живое ревью → merge. Эта стратегия снижает ручные ошибки и обеспечивает единообразие (при соблюдении `StyleGuide` и высокого порога тестового покрытия).

---
**Источники:** задачи и архитектура проекта описаны в спецификациях (UserStory, Architecture, API, Components, StyleGuide). Их положения заложены в требования и задачи каждого спринта.

Написать StyleGuide заново
Полировка и дебаг проекта